C251 COMPILER V5.60.0,  main                                                               18/08/23  10:25:11  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\OutPut\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C251\BIN\C251.EXE main.c XSMALL INTR2 BROWSE DEBUG PRINT(.\Listings\main.lst) OBJECT(.\O
                    -utPut\main.obj) 

stmt  level    source

    1          #include ".\comm\head.h"
    2          
    3          #define MAIN_Fosc        12000000L   //¶¨ÒåÖ÷Ê±ÖÓ£¨¾«È·¼ÆËã115200²¨ÌØÂÊ£©
    4          #define Baudrate      115200L
    5          #define TM            (65536 -(MAIN_Fosc/Baudrate/4))
    6          
    7          
    8          /*************  ±¾µØ³£Á¿ÉùÃ÷    **************/
    9          
   10          #define ADC_SPEED       15              /* 0~15, ADC×ª»»Ê±¼ä(CPUÊ±ÖÓÊý) = (n+1)*32  ADCCFG */
   11          #define RES_FMT         (1<<5)  /* ADC½á¹û¸ñÊ½ 0: ×ó¶ÔÆë, ADC_RES: D11 D10 D9 D8 D7 D6 D5 D4, ADC_RESL: D3 D2 D1 
             -D0 0 0 0 0 */
   12                                                                  /* ADCCFG      1: ÓÒ¶ÔÆë, ADC_RES: 0 0 0 0 D11 D10 D9 D8, ADC_RESL: D7 D6 D5 D4 D3 D2 D1 D0 */
   13          
   14          /*************  ±¾µØ±äÁ¿ÉùÃ÷    **************/
   15          
   16          unsigned char adc_result[256];
   17          unsigned char temp_result[10];
   18          unsigned char mcuid[20];
   19          unsigned char temp_mcuid[10];
   20          unsigned char rec_buffer[UART1_BUF_LENGTH];
   21          unsigned char temp_buffer[10];
   22          
   23          /*************  ±¾µØº¯ÊýÉùÃ÷    **************/
   24          
   25          void    delay_ms(u8 ms);
   26          void    ADC_convert(u8 chn);    //chn=0~7¶ÔÓ¦P1.0~P1.7, chn=8~14¶ÔÓ¦P0.0~P0.6, chn=15¶ÔÓ¦BandGapµçÑ¹
   27          u16     Get_ADC12bitResult(u8 channel);
   28          
   29          /**********************************************/
   30          void main(void)
   31          {
   32   1              u8      i;
   33   1      
   34   1      
   35   1          WTST = 0;  //ÉèÖÃ³ÌÐòÖ¸ÁîÑÓÊ±²ÎÊý£¬¸³ÖµÎª0¿É½«CPUÖ´ÐÐÖ¸ÁîµÄËÙ¶ÈÉèÖÃÎª×î¿ì
   36   1          EAXFR = 1; //À©Õ¹¼Ä´æÆ÷(XFR)·ÃÎÊÊ¹ÄÜ
   37   1          CKCON = 0; //Ìá¸ß·ÃÎÊXRAMËÙ¶È
   38   1      
   39   1          P0M1 = 0x7f;   P0M0 = 0x00;   //ÉèÖÃÎª¸ß×èÊäÈë
   40   1          P1M1 = 0xfb;   P1M0 = 0x00;   //ÉèÖÃÎª¸ß×èÊäÈë
   41   1          P2M1 = 0x3c;   P2M0 = 0x3c;   //ÉèÖÃP2.2~P2.5ÎªÂ©¼«¿ªÂ·(ÊµÑéÏä¼ÓÁËÉÏÀ­µç×èµ½3.3V)
   42   1          P3M1 = 0x50;   P3M0 = 0x50;   //ÉèÖÃP3.4¡¢P3.6ÎªÂ©¼«¿ªÂ·(ÊµÑéÏä¼ÓÁËÉÏÀ­µç×èµ½3.3V)    P3M1 = 0x50;   
             -P3M0 = 0x54;   
   43   1          P4M1 = 0x3c;   P4M0 = 0x3c;   //ÉèÖÃP4.2~P4.5ÎªÂ©¼«¿ªÂ·(ÊµÑéÏä¼ÓÁËÉÏÀ­µç×èµ½3.3V)
   44   1          P5M1 = 0x1c;   P5M0 = 0x0c;   //ÉèÖÃP5.2¡¢P5.3ÎªÂ©¼«¿ªÂ·(ÊµÑéÏä¼ÓÁËÉÏÀ­µç×èµ½3.3V)£¬ÉèÖÃP5.4Îª¸ß×èÊäÈ
             -ë
   45   1          P6M1 = 0xff;   P6M0 = 0xff;   //ÉèÖÃÎªÂ©¼«¿ªÂ·(ÊµÑéÏä¼ÓÁËÉÏÀ­µç×èµ½3.3V)
   46   1          P7M1 = 0x00;   P7M0 = 0x00;   //ÉèÖÃÎª×¼Ë«Ïò¿Ú
   47   1      
   48   1              ADCTIM = 0x3f;  //ÉèÖÃÍ¨µÀÑ¡ÔñÊ±¼ä¡¢±£³ÖÊ±¼ä¡¢²ÉÑùÊ±¼ä
   49   1              ADCCFG = RES_FMT + ADC_SPEED;
   50   1              //ADCÄ£¿éµçÔ´´ò¿ªºó£¬ÐèµÈ´ý1ms£¬MCUÄÚ²¿ADCµçÔ´ÎÈ¶¨ºóÔÙ½øÐÐAD×ª»»
   51   1              ADC_CONTR = 0x80 + 0;   //ADC on + channel
   52   1      
   53   1              UART1_config(2);
   54   1              EA = 1;
   55   1              
C251 COMPILER V5.60.0,  main                                                               18/08/23  10:25:11  PAGE 2   

   56   1              P32 = 1;
   57   1              printf("NanDu Program Start\r\n");
   58   1              printf("ÄÏ¶¼Æû³µµç×Ó×èÖµ¼ì²â£¬°æ±¾ºÅ£ºVer%02d.%02d!\r\n",Major_Ver,Minor_Ver);
   59   1              P32 = 0;
   60   1              
   61   1              for(i=0; i<7; i++)
   62   1                      {
   63   2                      printf("%02X",ID_ADDR[i]);      
   64   2                      sprintf (temp_mcuid,"%02X",ID_ADDR[i]);
   65   2                      strcat(mcuid,temp_mcuid);
   66   2                      }
   67   1                      mcuid[15]='\0';
   68   1                      printf("MCUID:%s \r\n",mcuid);
   69   1              while (1)
   70   1              {
   71   2                      if(TX1_Cnt != RX1_Cnt) P32 = 1;
   72   2                      else 
   73   2                      {
   74   3                              rec_buffer[0]='\0';
   75   3                              P32 = 0;
   76   3                      }
   77   2                      adc_result[0] = '\0';   
   78   2                      
   79   2                      delay_ms(10);
   80   2                       if((TX1_Cnt != RX1_Cnt) && (!B_TX1_Busy))   //ÊÕµ½Êý¾Ý, ·¢ËÍ¿ÕÏÐ
   81   2              {
   82   3                                                      P32 = 1;
   83   3                                                sprintf (temp_buffer,"%c",RX1_Buffer[TX1_Cnt]);
   84   3                                                strcat(rec_buffer,temp_buffer);
   85   3      //            SBUF = RX1_Buffer[TX1_Cnt];
   86   3      //            B_TX1_Busy = 1;
   87   3                  if(++TX1_Cnt >= UART1_BUF_LENGTH)   TX1_Cnt = 0;
   88   3                                                      
   89   3              } 
   90   2                                      
   91   2                                      if(strcmp(rec_buffer,mcuid)==0)
   92   2                                      {
   93   3                                                      for(i=0; i<15; i++)
   94   3                                              {
   95   4                                                      delay_ms(10);
   96   4                                                      ADC_convert(i);         //·¢ËÍÂÖÑ¯Í¨µÀADÖµ
   97   4                                              }
   98   3                                                      printf("MCUID;%s;",mcuid);
   99   3                                                      printf("adc_result;%s",adc_result);     
  100   3                                                      printf("\r\n");
  101   3                              }
  102   2                                      
  103   2              }
  104   1      }
  105          
  106          
  107          //========================================================================
  108          // º¯Êý: u16 Get_ADC12bitResult(u8 channel))    //channel = 0~15
  109          // ÃèÊö: ²éÑ¯·¨¶ÁÒ»´ÎADC½á¹û.
  110          // ²ÎÊý: channel: Ñ¡ÔñÒª×ª»»µÄADC, 0~15.
  111          // ·µ»Ø: 12Î»ADC½á¹û.
  112          // °æ±¾: V1.0, 2016-4-28
  113          //========================================================================
  114          u16     Get_ADC12bitResult(u8 channel)  //channel = 0~15
  115          {
  116   1              ADC_RES = 0;
  117   1              ADC_RESL = 0;
  118   1      
  119   1          ADC_CONTR = (ADC_CONTR & 0xf0) | channel; //ÉèÖÃADC×ª»»Í¨µÀ
  120   1          ADC_START = 1;//Æô¶¯ADC×ª»»
  121   1          _nop_();
C251 COMPILER V5.60.0,  main                                                               18/08/23  10:25:11  PAGE 3   

  122   1              _nop_();
  123   1              _nop_();
  124   1              _nop_();
  125   1          while(ADC_FLAG == 0);   //wait for ADC finish
  126   1          ADC_FLAG = 0;     //Çå³ýADC½áÊø±êÖ¾
  127   1              return (((u16)ADC_RES << 8) | ADC_RESL);
  128   1      }
  129          
  130          #define         SUM_LENGTH      16      /* Æ½¾ùÖµ²ÉÑù´ÎÊý ×î´óÖµ16 */
  131          
  132          /***********************************
  133          ²éÑ¯·½Ê½×öÒ»´ÎADC, chnÎªÍ¨µÀºÅ, chn=0~7¶ÔÓ¦P1.0~P1.7, chn=8~14¶ÔÓ¦P0.0~P0.6, chn=15¶ÔÓ¦BandGapµçÑ¹.
  134          ***********************************/
  135          void ADC_convert(u8 chn)
  136          {
  137   1              u16     j;
  138   1              u8      k;              //Æ½¾ùÖµÂË²¨Ê±Ê¹ÓÃ
  139   1              double f;
  140   1      
  141   1              Get_ADC12bitResult(chn);                //²ÎÊýi=0~15,²éÑ¯·½Ê½×öÒ»´ÎADC, ÇÐ»»Í¨µÀºóµÚÒ»´Î×ª»»½á¹û¶ªÆú. ±ÜÃâ²ÉÑùµçÈÝµÄ²Ð
             -´æµçÑ¹Ó°Ïì.
  142   1              Get_ADC12bitResult(chn);                //²ÎÊýi=0~15,²éÑ¯·½Ê½×öÒ»´ÎADC, ÇÐ»»Í¨µÀºóµÚ¶þ´Î×ª»»½á¹û¶ªÆú. ±ÜÃâ²ÉÑùµçÈÝµÄ²Ð
             -´æµçÑ¹Ó°Ïì.
  143   1              for(k=0, j=0; k<SUM_LENGTH; k++)        j += Get_ADC12bitResult(chn);   // ²ÉÑùÀÛ¼ÓºÍ, ²ÎÊý0~15,²éÑ¯·½Ê½×öÒ»´ÎADC
             -, ·µ»ØÖµ¾ÍÊÇ½á¹û
  144   1              j = j / SUM_LENGTH;             // ÇóÆ½¾ù
  145   1      
  146   1              f=get_r(300,j);
  147   1      
  148   1              if(chn != 15)
  149   1              {                       
  150   2      //              printf("ADC%02d=%0.2f \r\n",chn,f);
  151   2              sprintf (temp_result,"%0.2f;",f);
  152   2              strcat(adc_result,temp_result);
  153   2              }
  154   1      }
  155          
  156          //========================================================================
  157          // º¯Êý: void delay_ms(u8 ms)
  158          // ÃèÊö: ÑÓÊ±º¯Êý¡£
  159          // ²ÎÊý: ms,ÒªÑÓÊ±µÄmsÊý, ÕâÀïÖ»Ö§³Ö1~255ms. ×Ô¶¯ÊÊÓ¦Ö÷Ê±ÖÓ.
  160          // ·µ»Ø: none.
  161          // °æ±¾: VER1.0
  162          // ÈÕÆÚ: 2013-4-1
  163          // ±¸×¢: 
  164          //========================================================================
  165          void delay_ms(u8 ms)
  166          {
  167   1              u16 i;
  168   1              do
  169   1              {
  170   2                      i = MAIN_Fosc / 6000;
  171   2                      while(--i);
  172   2              }while(--ms);
  173   1      }
  174          
  175          float get_r(float R0,unsigned int ad)
  176          {
  177   1              float r;
  178   1      //      if(ad >= 1228200) return(1228200);
  179   1              r=R0*(float)ad/(float)(4095.00-ad);     
  180   1      //      if(r<=1) r=1;
  181   1              if(r >= 51000) return(51000);
  182   1              return(r);
  183   1      }

C251 COMPILER V5.60.0,  main                                                               18/08/23  10:25:11  PAGE 4   


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       639     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       434     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       122     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
